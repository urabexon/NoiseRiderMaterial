#define SCALE 1.
#define T ((sin(iTime*.3)*2.)+iTime*2.)
#define R(a) mat2(cos(a+vec4(0,33,11,0)))
#define N normalize

float tunnel(vec3 p, float r) {
    p = abs(p);
    return min(r - p.x,r - p.y);
}

vec4 marchVoxels(vec3 fp, vec3 sd, vec3 rs, vec3 dd, float iters, float minS,
                 out int side, float radius) {

    vec3 q;
    float i,os=0.,s,d=0.;
	for (i=0.; i++ < iters;) {

        if(sd.x <= sd.y && sd.x <= sd.z){
            sd.x += dd.x; // Add delta dist
            fp.x += rs.x; // step right/left
            side = 0;    // yz wall
        } else if(sd.y <= sd.z && sd.y <= sd.x) {
            sd.y += dd.y; // Add delta dist
            fp.y += rs.y; // step up/down
            side = 1;    // xz wall
        }  else {
            sd.z += dd.z; // Add delta dist
            fp.z += rs.z; // step front/back
            side = 2;    // xy wall
        }
        
        s = tunnel(fp*SCALE, radius);
        d += s;
		if (s < minS) break;

	}
    
    return vec4(fp, i);
}

// I based this on @chronos' "Lode Style Voxel DDA 3D"
// https://www.shadertoy.com/view/X32SD3
vec3 tex(vec3 ro, vec3 rd, vec3 p, vec3 n) {
    vec3 rgb;                         
    
    // Solve ray plane intersection equation: dot(n, ro + t * rd - p = 0.
    // for t 
    float t = dot(n, p - ro) / dot(n, N(rd));
    vec3 hit = ro + N(rd) * t;
    rgb = mix(rgb,abs(vec3(1,2,1e1) / dot(cos(iTime+hit*4.)*.1+sin(iTime+hit*.1),vec3(.1))),.01);
   
    return rgb;
}

void mainImage(out vec4 o, vec2 u) {
    int side;
    vec4  vox;
    vec3  id,
          n,
          lights,
          blue = vec3(.15,.11,.57)*1.5,
          red = vec3(.7,.11,.05)*2.5,
          green = vec3(.11,.32,.11)*1.5,
          r = iResolution;
    u = (u-r.xy/2.)/r.y
        // move camera around
        + vec2(sin(T*.4)*.4,
              sin(T*.3)*.4);;
          // rayPos
    vec3  p = vec3(0,0,T*2e1)/SCALE, ro = p,
          
          // rayDir
          rd = vec3(R(tanh(sin(p.z*.005)*4.)*3.)*R(sin(T*.3)*.5)*u, 1);
              
    // rayStep
	vec3 rs = sign(rd),
         // deltaDist
	     dd = 1. / abs(rd),
         // sideDist
		 sd = (rs * (floor(p) - p) + (rs * 0.5) + 0.5) * dd; 

    // clear o
    o = vec4(0);

    // first march
    vox = marchVoxels(floor(p), sd, rs, dd, 300., .01, side, 16.);
    n = vec3(side==0, side==1, side==2);
    p = vox.xyz  + .5 - rs * .5;
    
    // square ights
    lights = .3*abs(sin(p) /
                  dot(sin(.2*T+p),vec3(5)));
    // plasma lights
    o.rgb += .3*tex(ro, rd, p, n);
    
    // change scale slightly
    p = ro*.95;
    
    // sideDist
	sd = (rs * (floor(p) - p) + (rs * 0.5) + 0.5) * dd; 

    // second march
    vox = marchVoxels(floor(p), sd, rs, dd, 300., .01, side, 24.);
    n = vec3(side==0, side==1, side==2);
    p = vox.xyz  + .5 - rs * .5;
    
    // square lights
    o.rgb += 4.*red*tex(ro, rd, p, n);
    
    // plasma lights
    lights += abs(blue*sin(p.yzx) /
                  dot(sin(.3*T+p.xyz),vec3(1e1)));
    
    // apply lights and inverse dist fade
    o.rgb += lights;
    o = tanh(7.*o/vox.w*exp(vox.w/45.));
}
