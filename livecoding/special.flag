struct LoopParams{
    int maxSteps;
    float maxDistance;
    float epsilon;
    float degreeFov;
};

LoopParams DefaultLoopParams(){
    LoopParams res;
    res.maxSteps = 1800;
    res.maxDistance = 12000.0;
    res.epsilon = 0.001;
    res.degreeFov = 90.0;
    return res;
}

struct CameraInfo{
    vec3 pos;
    vec3 dir;
    vec3 u;
    vec3 v;
};

CameraInfo DefaultCamera(){
    CameraInfo res;
    res.pos = vec3(cos(iTime)*3.0, sin(iTime)*3.0-iTime*268.0, -9.0); // Camera Pos
    res.dir = normalize(vec3(sin(iTime*0.4)* sin(iTime*0.163) * 0.3, cos(iTime*0.4) * sin(iTime*0.123) * 0.6, 1.0));       // Camera Dir
    float t2 = iTime + 0.4*sin( iTime + 0.3*sin(iTime)) * 0.5;
    res.u = normalize(cross(vec3(sin(t2*0.9)* sin(t2*0.563) * 0.3, 1.0, sin(t2*0.9)* sin(t2*0.563) * 0.3), res.dir)); // Camera-U
    res.v = normalize(cross(res.dir, res.u));     // Camera-V
    return res;
}

struct RayResult{
    vec3 pos;
    vec3 dir;
    bool hit;
    vec4 col;
};

RayResult DefaultResult(CameraInfo cam){
    RayResult res;
    res.pos = cam.pos;
    res.hit = false;
    res.col = vec4(0.0);
    return res;
}

// Loop Info End

////////

struct TargetObject{
    vec3 center;
    vec3 size;
    int type;
    vec3 boundMin;
    vec3 boundMax;
};


float randOld(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

float randOld3(vec3 co){
    return fract(sin(dot(co, vec3(12.9898, 78.233, 51.231))) * 43758.5453);
}

float RandForTree(vec3 pos, float stage){
    int ratio = 1<<(1*int(stage));
    return randOld3(pos *float(ratio)/1e5 );
}

TargetObject WhichObjectToRender(vec3 pos){
    TargetObject res;
    float initSize = 129.0;
   
    
    vec3 currSize = vec3(initSize,initSize,initSize);
    vec3 currMin = floor(pos/currSize)*currSize;
    vec3 currMax = currMin + currSize;
    
    for(int i=0; i<7; i++){
        float r = RandForTree(currMin, float(i));
        if(r<0.021){
            res.center = (currMin + currMax)*0.5;
            res.size = currSize*0.35;
            res.type = i;
            res.boundMin = currMin;
            res.boundMax = currMax;
            return res;
        }
        if(r<0.491){
            res.center = (currMin + currMax)*0.5;
            res.size = currSize*0.0;
            res.type = i;
            res.boundMin = currMin;
            res.boundMax = currMax;
            return res;
        }
        
        currSize /= 2.0;
        currMin = floor(pos/currSize)*currSize;
        currMax = currMin + currSize;
    }
    
    res.center = (currMin + currMax)*0.5;
    res.size = currSize*0.0;
    res.type = 3;
    res.boundMin = currMin;
    res.boundMax = currMax;
    return res;
    
    
}



////////

struct SdfResult{
    float dist;
    vec3 boundCenter;
    vec3 boundSize;
};


SdfResult SceneSDF(vec3 p){
    SdfResult res;
    TargetObject to = WhichObjectToRender(p);
    res.dist = sdBox(p - to.center, to.size) - 0.3*to.size.x;
    res.boundCenter = (to.boundMin + to.boundMax)*0.5;
    res.boundSize = abs(to.boundMax - to.boundMin);
    //res.dist = sdBox(rgr(p,vec3(1.,1.,1.),iTime) , vec3(2.,1.,1.));
    //res.dist = smin(sdSphere(rgr(p - 4.*vec3(0.0,cos(iTime*4.3),sin(iTime*1.4)),vec3(2.,1.,1.),iTime*1.9) , 1.0),res.dist, 1.0);
    return res;
}


vec3 SceneNormal(vec3 p) {
    float epsilon = 0.003;
    vec3 n;
    float neutral = SceneSDF(p - vec3(0.0, 0.0, 0.0)).dist;
    n.x = SceneSDF(p + vec3(epsilon, 0.0, 0.0)).dist - neutral;
    n.y = SceneSDF(p + vec3(0.0, epsilon, 0.0)).dist - neutral;
    n.z = SceneSDF(p + vec3(0.0, 0.0, epsilon)).dist - neutral;
    return normalize(n);
}


void mainImage( out vec4 fragColor, in vec2 fragCoord ) {

    // Minimum In/Out
    vec2 p = 2.0 * (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    vec3 col = vec3(0.0);

    // Init Structs
    LoopParams lpar = DefaultLoopParams();
    CameraInfo cam = DefaultCamera();
    RayResult ray = DefaultResult(cam);

    // Loop
    
    ray.dir = normalize(cam.u * p.x + cam.v * p.y + cam.dir / tan(lpar.degreeFov / 180.0 * PI / 2.0)); // Ray Dir

    for (int i = 0; i < lpar.maxSteps; i++) {
        SdfResult receive =  SceneSDF(ray.pos);
        float nearest = receive.dist; 
        if (nearest < lpar.epsilon) {
            ray.hit = true;
            ray.col.xyz = SceneNormal(ray.pos) * vec3(0.5) + vec3(0.5);
            break;
        }
        vec3 prevPos = ray.pos;
        vec3 nextPos = ray.pos + nearest * ray.dir;
        
        
        vec3 vOut = (nextPos - receive.boundCenter);
        vec3 dirOut = normalize(vOut);
        vec3 boundMin = receive.boundCenter - receive.boundSize*0.5;
        vec3 boundMax = receive.boundCenter + receive.boundSize*0.5;
        
        float ratio = 1.0;
        ratio = min(ratio, abs(boundMin.x - prevPos.x)/abs(nextPos.x - prevPos.x));
        ratio = min(ratio, abs(boundMin.y - prevPos.y)/abs(nextPos.y - prevPos.y));
        ratio = min(ratio, abs(boundMin.z - prevPos.z)/abs(nextPos.z - prevPos.z));
        ratio = min(ratio, abs(boundMax.x - prevPos.x)/abs(nextPos.x - prevPos.x));
        ratio = min(ratio, abs(boundMax.y - prevPos.y)/abs(nextPos.y - prevPos.y));
        ratio = min(ratio, abs(boundMax.z - prevPos.z)/abs(nextPos.z - prevPos.z));
        
        nextPos = ray.pos + (nearest * ray.dir)*ratio + normalize(nearest * ray.dir)*0.1;
        
        
        ray.pos = nextPos;
        
        if (length(ray.pos - cam.pos) > lpar.maxDistance) break;
    }


    if (ray.hit) {
        col = ray.col.xyz; // 赤色
    } else {
        col = vec3(0.0); // 黒色
    }


    fragColor = vec4(col, 1.0);
}
